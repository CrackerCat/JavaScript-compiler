*汇编编译器：
·汇编语言的编译器
·汇编语言的大部分命令都和机器码一一对应，而高级语言和汇编的伪指令是不和机器码一一对应的 ，因此从某种意义上说，汇编码就相当于机器码。所以汇编器实现起来非常简单
·编译器的作用是，将源文件（.c/.cpp/.pas等）转换为目标代码（.obj/.dcu等）。这是已经是二进制代码了。 最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件
·机器码和汇编语言之间是一一对应的关系。汇编程序中存有汇编指令（助记符）和机器码（机器指令）之间一一对应关系的对照表。通过扫描查找对照表可以将汇编指令序列快速地翻译为机器码序列，这样就把你的汇编源程序翻译为目标程序，进而通过链接后生成可执行的机器码文件（如exe文件）。
·《汇编指令与机器码的相互转换【转】》：https://blog.csdn.net/p312011150/article/details/79612379


*汇编语言分类：
  汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。
  IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。
  CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。
  从汇编格式分，还有Intel格式和AT&T格式的区别，前者是Intel的，windows平台常见，后者最早由贝尔实验室推出，用于Unix中，GUN汇编器的缺省格式就是AT&T。不过GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT&T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。
  所谓 内嵌汇编，它是用于C语言和汇编语言混合编程的，所以和编译器也关系紧密，目前也是有两种，GNU的内嵌汇编和MASM的内嵌汇编，它们的语法和普通汇编是有区别的，特别是GNU的内嵌汇编不是很容易看懂，需要专门学习才行。MASM的内嵌汇编和普通汇编的区别则不大。
  关于汇编语言的种类，可以说有多少种不同内核的CPU，就有多少种汇编语言。汇编并不是只有8086/8088汇编，还有8051,ARM,Alpha,MIPS汇编等等...
  如你所知， 汇编是一种面向机器的编程语言，之所以说面向机器是指它的指令系统与具体的CPU芯片相关联，通常不同CPU硬件有不同的汇编系统。8086&8088分别是Intel公司的16位和准16位的CPU,通常使用它作为教材讲解微机机系统原理，是因为80x86系列CPU应用广泛，具有代表性。
  8051主要应用在单片机，ARM汇编用于ARM处理器...不需要解释。
  8086是INTEL公司推出的最早实际应用到微型个人计算机上CPU芯片型号；80x86是在8086基础上的增强型，包括80286，80386，80486，其后就改称奔腾了。大的区别上：8086和80286是16位的CPU，80386和80486是32位CPU；80486还多了数学辅助处理器，增强了复杂的数学运算能力。小的区别上就比较多了，如频率越来越快，包括寄存器的增加等。
  和C语言不同，汇编语言更多的针对特定CPU内核，因此，不同内核的CPU，必须有对应的汇编语言编译器将汇编语言别写的程序编译成对应CPU的机器语言代码，CPU才能正确识别和执行这些代码。


