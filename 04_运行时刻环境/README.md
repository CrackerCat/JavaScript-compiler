## 前言：
&emsp;&emsp;从词法分析，到语法分析，到三地址代码生成，这个几个阶段的本质还只是对字符串的转换，是静态编译阶段。而运行时指的是程序执行顺序、执行环境、内存动态分配等内容。
</br>
&emsp;&emsp;运行时刻跟编译时刻虽然是两个不同的阶段，但是由于运行时刻用到的指令是由编译器生成的，要使编译器生成正确指令，必需对程序运行时有足够的了解。

## 内容：
* 操作系统给内存进行规划，将内存大概分成操作系统内核内存和给程序员使用的内存2大部分，这样的好处是：操作系统的内存不会被大量占用，避免机器卡住、卡死、死机等状态，可通过操作系统把应用程序关闭，使得操作系统更安全。
* 内存空间之间是连续的
* 操作系统的内存具体规划，从低位到高位分别是：
  <br/>
  ~&emsp;代码段：函数编译成opcode(二进制)后存到磁盘，运行时将二进制从磁盘加载到内存中。
  <br/>
  ~&emsp;数据段（静态空间）：全局变量、常量、静态变量存数据段
  <br/>
  ~&emsp;堆：比栈内存大得多，一般有几G大小。
  <br/>
  ~&emsp;自由可分配内存：
  <br/>
  ~&emsp;栈：第一个函数运行时压入栈底，函数调新函数时再往栈里压入该新函数，新函数运行完即出栈，第一个函数运行完再出栈，栈为空
  <br/>
  ~&emsp;系统内核：操作系统给内存进行规划，将内存大概分成操作系统内核内存和给程序员使用的内存2大部分，这样的好处是：操作系统的内存不会被大量占用，避免机器卡住、卡死、死机等状态，可通过操作系统把应用程序关闭，使得操作系统更安全。
* 关于程序调用的系统栈的分析：当函数A执行到第2行时，开始运行函数B，此时A停止开始运行B，并向系统栈中压入A2（表示函数A的第2行），当B执行到第2行时开始运行函数C，并在系统栈中压入B2，当C运行完时再查看系统栈，发现了B2，系统开始继续执行B的第2行，B执行完后查看系统栈，发现A2，则继续执行A直到完成。
* 符号表简介：编译器各种阶段都可能跟表格产生联系
* 符号表的作用：
  <br/>
  ~&emsp;一致性检查：查符号表检查标示符是否为标号（label）
  <br/>
  ~&emsp;作用域分析：同一个名字在不同函数嵌套中代表的地址不一样
  <br/>
  ~&emsp;辅助代码生成：为目标代码生成进行优化提供信息
* 符号表实例：
  ```
  NAME        INFORMATION
  index       整型，变量
  socre       实型，变量
  p           数组，形式参数
  ```
* 常见符号表：
  <br/>
  ~&emsp;名字表(nametab)
  <br/>
  ~&emsp;程序体表（btab）
  <br/>
  ~&emsp;层次显示表（display）
  <br/>
  ~&emsp;数组信息表（atab）
  <br/>
  ~&emsp;中间代码表（code）
* 作用域分为：词法作用域和环境作用域（执行时作用域/动态作用域）
* 词法作用域：在词法分析时就可以知道一个变量的作用域，如果是有一个作用域，则创建一个block，满足“最近嵌套原则”，并形成一个作用域链
* 词法闭包：在词法分析时就可以知道闭包的存在
* 执行环境：除了程序员自身写的代码外，程序自身会自带一个全局运行环境，例如js中在浏览器中的window对象，在node环境中的global对象
* 全局运行环境的组成：
  <br/>
  ~&emsp;hashmap：{}
  <br/>
  ~&emsp;level：0  //环境当前的嵌套层级，初始为0
  <br/>
  ~&emsp;parent：sp  //子环境（字作用域）指向父环境的指针
* 子作用域：js在调用函数时会创建一个子环境，并且，父环境对象作为一个参数传入这个子环境对象创建当中，这个子环境就是一个子作用域
* 三地址表达式实例2（斐波那契函数）栈的运行图示：
  ```
    栈空间（通过指针偏移拿到数据）     代码段空间（通过行号值拿到数据）    
  |  link7   |                           
  //link7会指向数字2                |     f    |
  |     2    |                     |  t1=n==1  |
  |  link6   |                     |  t2=n==2  |
  |  link5   |                     |t3=t1 or t2|
  |其他临时变量|                    |           |
  |  返回值3 |                      |branch goto|
  |     3    |                     |   ...     |
  |  link4   |                     |           |
  |  link3   |                     |           |
  |其他临时变量|                    |           |
  |  返回值2 |                      |          |
  |     4    |                     |           |
  |  link2   |                     |           |
  //link2会指向数字5                |           |
  |  link1   |                     |           |
  //link1会指向代码call f           |           |
  |其他临时变量|                    |           |
  |  返回值1 |                      |          |
  //返回值可根据5的偏移量计算拿到     |  call f  |
  |     5    |                     //call f将指向第一行f
  ------------                     --------------
  ```
* 定义三地址码生成规则：
  <br/>
  ~&emsp;@：表示作用域
  <br/>
  ~&emsp;set：赋值
  <br/>
  ~&emsp;branch：if语句判断
  <br/>
  ~&emsp;$：临时变量
  <br/>
  ~&emsp;call：调用函数
  <br/>
  ~&emsp;section：区块
  <br/>
  ~&emsp;%:寄存器，%TOP%表示TOP寄存器
  <br/>
  ~&emsp;SP：指针
  <br/>
  ~&emsp;call：函数调用
  <br/>
  ~&emsp;pass：表示传参
* 源码 → 三地址
  ```
  function fibonacci(n){
    if(n==1 || n==2){
      return n
    }
    return fibonacci(n-1)+fibonacci(n-2)
  }
  print(fibonacci(5))
  ```
  转换后的三地址码：
    ```
    section fibonacci@2
    set %TOP% %SP%
    set $t1@2 n==1
    set $t2@2 n==2
    set $t3@2 $t1@2 || $t2@2
    branch $t3@2 LB1  //$t3@2为true时继续，否则跳转到LB1行
    return n@2
    LB1:set $t4@2 n-1
    pass $t4@2    //pass表示传参，压栈
    call fibonacci@1
    set $6@2 n-2
    pass $t6@2    //pass表示传参，压栈
    call fibonacci@1
    set $t8@2 $t5@2 + $t7@2
    return $t8@2@2
    section main@1
    set %TOP% %SP%
    declare function fibonacci@1
    pass 5
    call fibonacci@1
    pass $t2@1
    call print@1
    ```

